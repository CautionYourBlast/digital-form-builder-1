{"version":3,"sources":["../../src/values/index.js"],"names":["Index","constructor","type","toStaticValues","data","Error","StaticValue","label","value","hint","condition","children","from","obj","StaticValues","valueType","items","map","it","JSON","stringify","ValueChildren","ListRefValues","list","valueChildren","findList","item","text","description","find","toJSON","valuesFactories","static","listRef","valuesFrom","valuesFactory","yesNoValues"],"mappings":";;AAcA,MAAMA,KAAN,CAAuC;AAErCC,EAAAA,WAAW,CAAEC,IAAF,EAAoB;AAAA;;AAC7B,SAAKA,IAAL,GAAYA,IAAZ;AACD;;AAEDC,EAAAA,cAAc,CAAEC,IAAF,EAAiC;AAAE;AAC/C,UAAMC,KAAK,CAAC,eAAD,CAAX;AACD;;AARoC;;AAWvC,MAAMC,WAAN,CAAkB;AAKM;AAEtBL,EAAAA,WAAW,CAAEM,KAAF,EAAiBC,KAAjB,EAA4CC,IAA5C,EAA2DC,SAA3D,EAA+EC,QAAkB,GAAG,EAApG,EAAwG;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AACjH,SAAKJ,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;AAED,SAAOC,IAAP,CAAaC,GAAb,EAAuB;AACrB,WAAO,IAAIP,WAAJ,CAAgBO,GAAG,CAACN,KAApB,EAA2BM,GAAG,CAACL,KAA/B,EAAsCK,GAAG,CAACJ,IAA1C,EAAgDI,GAAG,CAACH,SAApD,EAA+DG,GAAG,CAACF,QAAnE,CAAP;AACD;;AAjBe;;AAoBlB,OAAO,MAAMG,YAAN,SAA2Bd,KAA3B,CAAiC;AAItCC,EAAAA,WAAW,CAAEc,SAAF,EAAyBC,KAAzB,EAAoD;AAC7D,UAAM,QAAN;;AAD6D;;AAAA;;AAE7D,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;;AAEDb,EAAAA,cAAc,CAAEC,IAAF,EAAiC;AAC7C,WAAO,IAAP;AACD;;AAED,SAAOQ,IAAP,CAAaC,GAAb,EAAqC;AACnC,QAAIA,GAAG,CAACX,IAAJ,KAAa,QAAjB,EAA2B;AAAA;;AACzB,aAAO,IAAIY,YAAJ,CAAiBD,GAAG,CAACE,SAArB,EAAgC,eAACF,GAAG,CAACG,KAAL,mDAAc,EAAd,EAAkBC,GAAlB,CAAsBC,EAAE,IAAIZ,WAAW,CAACM,IAAZ,CAAiBM,EAAjB,CAA5B,CAAhC,CAAP;AACD;;AACD,UAAMb,KAAK,CAAE,+CAA8Cc,IAAI,CAACC,SAAL,CAAeP,GAAf,CAAoB,EAApE,CAAX;AACD;;AAnBqC;;AAsBxC,MAAMQ,aAAN,CAAoB;AAEI;AAEtBpB,EAAAA,WAAW,CAAEO,KAAF,EAA6BG,QAA7B,EAAmD;AAAA;;AAAA;;AAC5D,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKG,QAAL,GAAgBA,QAAhB;AACD;;AAED,SAAOC,IAAP,CAAaC,GAAb,EAAuB;AACrB,WAAO,IAAIQ,aAAJ,CAAkBR,GAAG,CAACL,KAAtB,EAA6BK,GAAG,CAACF,QAAjC,CAAP;AACD;;AAXiB;;AAcpB,MAAMW,aAAN,SAA4BtB,KAA5B,CAAkC;AAIhCC,EAAAA,WAAW,CAAEsB,IAAF,EAAgBC,aAAhB,EAAqD;AAC9D,UAAM,SAAN;;AAD8D;;AAAA;;AAE9D,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACD;;AAEDrB,EAAAA,cAAc,CAAEC,IAAF,EAAiC;AAC7C,QAAI,KAAKmB,IAAT,EAAe;AACb,YAAMA,IAAI,GAAGnB,IAAI,CAACqB,QAAL,CAAc,KAAKF,IAAnB,CAAb;;AACA,UAAIA,IAAJ,EAAU;AACR,eAAO,IAAIT,YAAJ,CAAiBS,IAAI,CAACrB,IAAtB,EACLqB,IAAI,CAACP,KAAL,CAAWC,GAAX,CAAeS,IAAI;AAAA;;AAAA,iBACjB,IAAIpB,WAAJ,CAAgBoB,IAAI,CAACC,IAArB,EAA2BD,IAAI,CAAClB,KAAhC,EAAuCkB,IAAI,CAACE,WAA5C,EAAyDF,IAAI,CAAChB,SAA9D,qDACE,KAAKc,aAAL,CAAmBK,IAAnB,CAAwBX,EAAE,IAAIA,EAAE,CAACV,KAAH,KAAakB,IAAI,CAAClB,KAAhD,CADF,2DACE,uBAAwDG,QAD1D,yEACsE,EADtE,CADiB;AAAA,SAAnB,CADK,CAAP;AAMD,OAPD,MAOO;AACL,cAAMN,KAAK,CAAE,iCAAgC,KAAKkB,IAAK,EAA5C,CAAX;AACD;AACF,KAb4C,CAc7C;;;AACA,WAAO,IAAIT,YAAJ,CAAiB,QAAjB,EAA2B,EAA3B,CAAP;AACD;;AAEDgB,EAAAA,MAAM,GAAI;AACR,WAAO;AAAEP,MAAAA,IAAI,EAAE,KAAKA,IAAb;AAAmBC,MAAAA,aAAa,EAAE,KAAKA;AAAvC,KAAP;AACD;;AAED,SAAOZ,IAAP,CAAaC,GAAb,EAAsC;AACpC,QAAIA,GAAG,CAACX,IAAJ,KAAa,SAAjB,EAA4B;AAAA;;AAC1B,aAAO,IAAIoB,aAAJ,CAAkBT,GAAG,CAACU,IAAtB,EAA4B,uBAACV,GAAG,CAACW,aAAL,mEAAsB,EAAtB,EAA0BP,GAA1B,CAA8BC,EAAE,IAAIG,aAAa,CAACT,IAAd,CAAmBM,EAAnB,CAApC,CAA5B,CAAP;AACD;;AACD,UAAMb,KAAK,CAAE,gDAA+Cc,IAAI,CAACC,SAAL,CAAeP,GAAf,CAAoB,EAArE,CAAX;AACD;;AArC+B;;AAwClC,MAAMkB,eAAe,GAAG;AACtBC,EAAAA,MAAM,EAAGnB,GAAD,IAASC,YAAY,CAACF,IAAb,CAAkBC,GAAlB,CADK;AAEtBoB,EAAAA,OAAO,EAAGpB,GAAD,IAASS,aAAa,CAACV,IAAd,CAAmBC,GAAnB;AAFI,CAAxB;AAKA,OAAO,SAASqB,UAAT,CAAqBrB,GAArB,EAAgD;AACrD,QAAMsB,aAAa,GAAGJ,eAAe,CAAClB,GAAG,CAACX,IAAL,CAArC;;AACA,MAAIiC,aAAJ,EAAmB;AACjB,WAAOA,aAAa,CAACtB,GAAD,CAApB;AACD;;AACD,QAAMR,KAAK,CAAE,6BAA4BQ,GAAG,CAACX,IAAK,cAAaiB,IAAI,CAACC,SAAL,CAAeP,GAAf,CAAoB,EAAxE,CAAX;AACD;AAED,OAAO,MAAMuB,WAAW,GAAG,IAAItB,YAAJ,CAAiB,SAAjB,EAA4B,CAAC,IAAIR,WAAJ,CAAgB,KAAhB,EAAuB,IAAvB,CAAD,EAA+B,IAAIA,WAAJ,CAAgB,IAAhB,EAAsB,KAAtB,CAA/B,CAA5B,CAApB","sourcesContent":["// @flow\n\nimport type { DataModel } from '../data-model-interface'\n\ntype ValuesType = 'static' | 'listRef';\ntype ValueTypes = 'string' | 'number' | 'boolean';\ntype ConcreteValueTypes = string | number | boolean;\n\nexport interface ComponentValues {\n  // Converts whatever type of values this is into a static values object\n  // suitable for rendering\n  toStaticValues(data: DataModel): StaticValues // eslint-disable-line\n}\n\nclass Index implements ComponentValues {\n  type: ValuesType\n  constructor (type: ValuesType) {\n    this.type = type\n  }\n\n  toStaticValues (data: DataModel): StaticValues { // eslint-disable-line\n    throw Error('Unimplemented')\n  }\n}\n\nclass StaticValue {\n  label: string;\n  value: ConcreteValueTypes;\n  hint: ?string;\n  condition: ?string;\n  children: Array<any>; // should be Array<Component> whenever someone introduces the appropriate class\n\n  constructor (label: string, value: ConcreteValueTypes, hint: ?string, condition: ?string, children: Array<*> = []) {\n    this.label = label\n    this.value = value\n    this.hint = hint\n    this.condition = condition\n    this.children = children\n  }\n\n  static from (obj: any) {\n    return new StaticValue(obj.label, obj.value, obj.hint, obj.condition, obj.children)\n  }\n}\n\nexport class StaticValues extends Index {\n  valueType: ValueTypes;\n  items: Array<StaticValue>;\n\n  constructor (valueType: ValueTypes, items: Array<StaticValue>) {\n    super('static')\n    this.valueType = valueType\n    this.items = items\n  }\n\n  toStaticValues (data: DataModel): StaticValues {\n    return this\n  }\n\n  static from (obj: any): StaticValues {\n    if (obj.type === 'static') {\n      return new StaticValues(obj.valueType, (obj.items ?? []).map(it => StaticValue.from(it)))\n    }\n    throw Error(`Cannot create from non static values object ${JSON.stringify(obj)}`)\n  }\n}\n\nclass ValueChildren {\n  value: ConcreteValueTypes;\n  children: Array<any>; // should be Array<Component> whenever someone introduces the appropriate class\n\n  constructor (value: ConcreteValueTypes, children: Array<any>) {\n    this.value = value\n    this.children = children\n  }\n\n  static from (obj: any) {\n    return new ValueChildren(obj.value, obj.children)\n  }\n}\n\nclass ListRefValues extends Index {\n  list: string;\n  valueChildren: Array<ValueChildren>;\n\n  constructor (list: string, valueChildren: Array<ValueChildren>) {\n    super('listRef')\n    this.list = list\n    this.valueChildren = valueChildren\n  }\n\n  toStaticValues (data: DataModel): StaticValues {\n    if (this.list) {\n      const list = data.findList(this.list)\n      if (list) {\n        return new StaticValues(list.type,\n          list.items.map(item =>\n            new StaticValue(item.text, item.value, item.description, item.condition,\n              this.valueChildren.find(it => it.value === item.value)?.children ?? [])\n          )\n        )\n      } else {\n        throw Error(`Could not find list with name ${this.list}`)\n      }\n    }\n    // just return some default values as we're not a completely defined component yet (used in the designer)\n    return new StaticValues('string', [])\n  }\n\n  toJSON () {\n    return { list: this.list, valueChildren: this.valueChildren }\n  }\n\n  static from (obj: any): ListRefValues {\n    if (obj.type === 'listRef') {\n      return new ListRefValues(obj.list, (obj.valueChildren ?? []).map(it => ValueChildren.from(it)))\n    }\n    throw Error(`Cannot create from non listRef values object ${JSON.stringify(obj)}`)\n  }\n}\n\nconst valuesFactories = {\n  static: (obj) => StaticValues.from(obj),\n  listRef: (obj) => ListRefValues.from(obj)\n}\n\nexport function valuesFrom (obj: any): ComponentValues {\n  const valuesFactory = valuesFactories[obj.type]\n  if (valuesFactory) {\n    return valuesFactory(obj)\n  }\n  throw Error(`No factory found for type ${obj.type} in object ${JSON.stringify(obj)}`)\n}\n\nexport const yesNoValues = new StaticValues('boolean', [new StaticValue('Yes', true), new StaticValue('No', false)])\n"],"file":"index.js"}